加  密  
====

计算机有很多安全防护  
但事实上, 世上不存在100%安全的系统 
总会有漏洞存在，而且安全专家知道这一点     
所以系统架构师会部署"多层防御"  
用多层不同的安全机制来阻碍攻击者  
> 有点像城堡的设计一样  
>> 首先要避开弓箭手  
>> ![1](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-1.jpg)    
>> 才能达到王座  
不过我们这里要说的是，计算机安全中最常见的防御形式   


## 密码学
密码学(cryptography)一词来自crypto和graphy，大致翻译成"秘密写作"   
为了加密信息，要用加密算法(Cipher)把明文转为密文   
除非你知道如何解密，不然密文看起来只是一堆乱码   
* 把明文转成密文叫"加密"(encryption)   
* 把密文恢复回明文叫"解密"(decryption)   
加密算法早在计算机出现前就有了   
> 朱利叶斯·凯撒用如今我们叫"凯撒加密"的方法来加密私人信件  
> 他会把信件中的字母向前移动三个位置    
> 所以A会变成D，brutus变成euxwxv  
> 为了解密，接收者要知道1、用了什么算法，2、要偏移的字母位数


## 替换加密  
有一大类算法叫"替换加密"，凯撒密码是其中一种
算法把每个字母替换成其他字母

### 但有个巨大的缺点: 字母的出现频率是一样的  
> E在英语中是最常见的字母  
> 如果把E加密成X  
> 那么密文中 X的出现频率会很高  
> 熟练的密码破译师可以从统计数据中发现规律，进而破译密码   
>> ![2](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-2.jpg)   

### 移位加密
另一类加密算法叫"移位加密"  
我们来看一个简单例子叫"列移位加密"   
> 我们把明文填入网格 
> 网格大小我们这里选择 5x5  
> 为了加密信息，我们换个顺序来读  
> 比如从左边开始，从下往上，一次一列。  
> 加密后字母的排列不同了  
>> 解密的关键是，知道读取方向和网格大小是5x5  
>> ![3](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-3.jpg)   

## 密码机器   
到了1900年代，人们用密码学做了加密机器     
其中最有名的是德国的英格玛(Enigma)纳粹在战时用英格玛加密通讯信息       
> Enigma是一台像打字机的机器，有键盘和灯板，两者都有完整的字母表    
> ![4](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-4.jpg)  

首先，我们只看一个转子  
它一面有26个接触点，代表26个字母，然后线会连到另一面，替换字母  
![5](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-5.jpg)  
* 这个字母替换过程你应该听起来很熟悉：它是"替换加密"!  

> 英格玛(Enigma)更复杂一些，因为它有3个或更多转子，一个转子的输出作为下一个转子的输入。  
> 转子还有26个起始位置  
>> ![6](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-6.jpg)  
> 转子之后是一个叫"反射器"的特殊电路   
> ![7](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-7.jpg)    
>> ![8](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-8.jpg)  
>> 又加了一层复杂度  

让我们用这里的简化版电路，加密一些字母     
如果我们按下"H"键，电流会先通过插板，然后通过转子    
![9](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-9.jpg)   
注意, 电路是双向的  
所以如果我们按下L，H会亮起来  
> 换句话说，加密和解密的步骤是一样的  
> 你只需要确保 发送机和接收机的初始配置一样就行  
> 如果你有仔细观察，会注意到字母加密后一定会变成另一个字母  
* 之后这成为最大的弱点  

最后，为了让英格玛不只是简单的"替换加密"  
每输入一个字母，转子会转一格，有点像汽车里程表。   
如果你输入A-A-A，可能会变成B-D-K，映射会随着每次按键而改变  
英格玛当然是一块难啃的骨头  
但正如[阿兰·图灵](https://github.com/KissMyLady/Computer/blob/master/Note/early_com3.md)讲的, 他破解了英格玛加密，并把大部分破解流程做成了自动化    


## 数据加密标准  
随着计算机出现，加密从硬件转往软件     
早期加密算法中，应用最广泛的     
是IBM和NSA于1977年开发的"数据加密标准"    
> 意味着有2^56次方，或大约72千万亿个不同密钥   
> 在1977年时，也许NSA有这能力，   
>> 但没有其他人有足够计算能力 来暴力破解所有可能密钥。  
>> ![10](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-10.jpg)  


## 高级加密标准  
因此2001年出了:高级加密标准(AES)  
![11](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-11.jpg)  
* 128位的密钥，哪怕用现在地球上的所有计算机, 也要上万亿年才能试遍所有组合  
你最好赶紧开始!   

再加上一些其他操作，进一步加密信息   
每一块数据，会重复这个过程10次或以上      
你可能想知道：为什么只重复10次？   
* 为什么用128位密钥，而不是10000位？      
> 这其实是基于性能的权衡    
> 如果要花几小时加密和发邮件，或几分钟载入网站，没人愿意用    

### AES被广泛使用     
如今AES被广泛使用，比如iPhone上加密文件  
用WPA2协议在WiFi中访问HTTPS网站  



## 密钥交换  
> 我们讨论过的加密, 依赖于发送者和接收者都知道密钥     
> 发件人用密钥加密，收件人用相同的密钥解密     
>> 以前，密钥可以口头约定，或依靠物品     
>> ![12](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-12.jpg)   
> 但互联网时代没法这样做, 你能想象 要打开密码本才能访问YouTube吗？  
* 我们需要某种方法: 在公开的互联网上传递密钥给对方  
这看起来好像不安全，如果密钥被黑客拦截了  
黑客不就能解密通信了吗？  
#### 解决方案是 "密钥交换"！ 

### 单项函数
密钥交换是一种不发送密钥, 但依然让两台计算机在密钥上达成共识的算法   
我们可以用"单向函数"来做    
* 单项函数是一种数学操作，很容易算出结果，但想从结果逆向推算出输入非常困难    

### 颜色比喻
为了让你明白单项函数，我们拿颜色作比喻      
* 将颜色混合在一起很容易，但想知道混了什么颜色很困难    

用这个比喻，那么我们的密钥是一种独特的颜色      
> 首先，有一个公开的颜色，所有人都可以看到    
> 然后，约翰和我各自选一个秘密颜色，只有自己知道.    
>> ![13](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-13.jpg)  
>> 然后发给约翰，可以写信发，用信鸽发，什么方式都行.    
>> 约翰也这样做，把他的秘密颜色和公开颜色混在一起，然后发我   
>>> 我收到约翰的颜色之后，把我的秘密颜色加进去，现在3种颜色混合在一起    
>>> 瞧! 我们有了一样的颜色    
>  
>　我们可以把这个颜色当密钥，尽管我们从来没有给对方发过这颜色   
>　外部窥探者可以知道部分信息，但无法知道最终颜色    
当然，计算机要传输数据时，混合颜料和发颜料不太合适  

 
## "迪菲-赫尔曼密钥交换"     
数学单向函数是完美的   
我们可以用"迪菲-赫尔曼密钥交换", 在Diffie-Hellman中，单向函数是模幂运算    
意思是先做幂运算，拿一个数字当底数，拿一个数字当指数，比如A          
然后除以第三个数字，最后拿到我们想要的余数  
> 举个例子，假设我们想算3的5次方，模31  
> 我们先算3的5次方，得到243  
> 然后除31，取余数，得到26  
>> 重点是, 如果只给余数和基数, 很难得知指数是多少  
>> 如果我告诉你，3的某次方 模31，余数是7  
>> 你要试很多次，才能知道次方是多少
>> 如果把数字变长一些，比如几百位长  
>> #### 想找到秘密指数是多少，几乎是不可能的。  


## Diffie-Hellman数学运算    
现在我们来讨论Diffie-Hellman是怎么用模幂运算, 算出双方共享的密钥  
> 首先，我们有公开的值-基数和模数  
> 就像公开的油漆颜色，所有人都看的到，甚至坏人!  
> 为了安全向John发信息，我选一个秘密指数：X  
> 
> 然后算B^X mod M的结果, 然后把这个大数字发给John.  
> 为了算出双方共用的密钥, 我把John给我的数，用我的秘密指数X，进行模幂运算  
> 数学上相等于B的XY次方模M   
>   
>> 双方有一样的密钥，即使我们从来没给对方发过各自的秘密指数    
>> 我们可以用这个大数字当密钥，用AES之类的加密技术来加密通信  
>> ![14](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-14.jpeg)  

## 对称加密与非对称加密  
"Diffie-Hellman密钥交换"是建立共享密钥的一种方法。   
双方用一样的密钥加密和解密消息，这叫"对称加密", 因为密钥一样  
凯撒加密，英格玛，AES都是"对称加密"  
还有"非对称加密"，有两个不同的密钥  
一个是公开的，另一个是私有的  
人们用公钥加密消息，只有有私钥的人能解密  

换句话说，知道公钥只能加密但不能解密, 它是"不对称"的！  
> 想象一个可以锁上的盒子  
> 为了收到安全的信息，我们可以给别人箱子和锁  
> 别人把信息放箱子，然后锁起来   
>> 把盒子寄回给我，只有我的钥匙能打开  
>> 上锁后，如果发件人或其他人想打开盒子, 除了暴力尝试没有其他办法.  

和盒子例子一样，公钥加密后只能私钥来解密 
反过来也是可以的：私钥加密后用公钥解密  
这种做法用于签名，服务器可以用私钥加密  
任何人都可以用服务器的公钥解密, 就像一个不可伪造的签名  
因为只有私钥的持有人能加密   


## 非对称加密--RSA  
这能证明数据来自正确的服务器或个人，而不是某个假冒者    
目前最流行的"非对称加密"技术是RSA, 名字来自发明者：Rivest, Shamir, Adleman   
现在你学会了现代密码学的所有"关键"部分：    
对称加密，密钥交换，公钥密码学   
> 当你访问一个安全的网站，比如银行官网     
>> 绿色锁图标代表 用了公钥密码学    
>> ![15](https://github.com/KissMyLady/Computer/blob/master/Image/Works/add-15.jpg)  
>> 验证服务器的密钥，然后建立临时密钥    
>> 然后用对称加密保证通信安全    
>> 不管你是网上购物，发邮件给朋友，还是看小姐姐视频   

密码学都在保护你的隐私和安全  
谢啦密码学！  


## 接下来    
